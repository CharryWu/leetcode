/**
这段代码实际运行的时候会有一个严重的问题，那就是整型溢出。

你想，上一道题给定的 DNA 序列字符串只包含 AGCT 四种字符，所以我们可以把 DNA 序列抽象成四进制的数字，即算法中 R = 4。相同位数下，四进制包含的数字数量是小于十进制包含的数字数量的。比方说 L = 10 时，4^10 = 1048576 < 10^8，即 10 位四进制数字用 8 位十进制数字就可以存下了。

但现在输入为 ASCII 码字符串，我们不得不把字符串抽象成 256 进制的数字，即算法中 R = 256。而相同位数下，256 进制包含的数字数量显然是远大于十进制包含的数字数量的。比如 L = 10 时，256^10 = 1.2 x 10^24 < 10 ^25，所以你需要一个 25 位的十进制数才能表示一个 10 位的 256 进制数。

可想而知，如果你真的把字符串对应的 256 进制数字的十进制表示作为该字符串的哈希值，那恐怕 L 稍微大一点，像 RL, windowHash, patHash 这些变量就超级大了，long 类型都远远装不下。

所以解决办法是什么呢？如何把一个很大的数字映射到一个较小的范围内呢？答案是求模（余数）。

无论一个数字多大，你让它除以 Q，余数一定会落在 [0, Q-1] 的范围内。所以我们可以设置一个 Q，用求模的方式让 windowHash 和 patHash 保持在 [0, Q-1] 之间，就可以有效避免整型溢出。

具体来说，对于一个字符串，我们不需要把完整的 256 进制数字存下来，而是对这个巨大的 256 进制数求 Q 的余数，然后把这个余数作为该字符串的哈希值即可。

好，整型溢出的问题倒是解决了，但新的问题又来了：求模之后的哈希值不能和原始字符串一一对应了，可能出现一对多的情况，即哈希冲突。

比方说 10 % 7 等于 3，而 17 % 7 也等于 3，所以如果你得到余数 3，你能确定原始数字就一定是 10 么？不能。

类似的，如果你发现 windowHash == patHash，你也不敢完全肯定窗口中的字符串一定就和模式串 pat 匹配，有可能它俩不匹配，但恰好求模算出来的哈希值一样，这就产生了是「哈希冲突」。

在我的 数据结构精品课 中哈希表的章节中用拉链法和线性探查法解决了哈希表的哈希冲突。对于 Rabin-Karp 算法来说，当发现 windowHash == patHash 时，使用暴力匹配算法检查一下窗口中的字符串和 pat 是否相同就可以避免哈希冲突了。因为希冲突出现的概率比较小，所以偶尔用一下暴力匹配算法是不影响总体的时间复杂度的。

明白了这些问题的解决方案，你就能很自然地写出 Rabin-Karp 算法了：
*/

// Rabin-Karp 指纹字符串查找算法
int rabinKarp(String txt, String pat) {
    // 位数
    int L = pat.length();
    // 进制（只考虑 ASCII 编码）
    int R = 256;
    // 取一个比较大的素数作为求模的除数
    long Q = 1658598167;
    // R^(L - 1) 的结果
    long RL = 1;
    for (int i = 1; i <= L - 1; i++) {
        // 计算过程中不断求模，避免溢出
        RL = (RL * R) % Q;
    }
    // 计算模式串的哈希值，时间 O(L)
    long patHash = 0;
    for (int i = 0; i < pat.length(); i++) {
        patHash = (R * patHash + pat.charAt(i)) % Q;
    }
    
    // 滑动窗口中子字符串的哈希值
    long windowHash = 0;
    
    // 滑动窗口代码框架，时间 O(N)
    int left = 0, right = 0;
    while (right < txt.length()) {
        // 扩大窗口，移入字符
        windowHash = ((R * windowHash) % Q + txt.charAt(right)) % Q;
        right++;

        // 当子串的长度达到要求
        if (right - left == L) {
            // 根据哈希值判断是否匹配模式串
            if (windowHash == patHash) {
                // 当前窗口中的子串哈希值等于模式串的哈希值
                // 还需进一步确认窗口子串是否真的和模式串相同，避免哈希冲突
                if (pat.equals(txt.substring(left, right))) {
                    return left;
                }
            }
            // 缩小窗口，移出字符
            windowHash = (windowHash - (txt.charAt(left) * RL) % Q + Q) % Q;
            // X % Q == (X + Q) % Q 是一个模运算法则
            // 因为 windowHash - (txt[left] * RL) % Q 可能是负数
            // 所以额外再加一个 Q，保证 windowHash 不会是负数

            left++;
        }
    }
    // 没有找到模式串
    return -1;
}

/**
有之前那么多铺垫，算法逻辑应该没啥可说的，就说一下模运算的两个运算法则吧：

X % Q == (X + Q) % Q
(X + Y) % Q == (X % Q + Y % Q) % Q

稍微想一想就能理解这两个运算法则，在代码中但凡涉及到乘法和加法，都可能产生很大的结果，所以一有机会就可以运用上述法则对结果进行求模，以避免造成溢出。

Rabin-Karp 算法的时间复杂度是 O(N + L)，N 为文本串 txt 的长度，L 为模式串 pat 的长度。当然，每次出现哈希冲突时会使用 O(L) 的时间进行暴力匹配，但考虑到只要 Q 设置的合理，哈希冲突的出现概率会很小，所以可以忽略不计。

最后说一下这个大素数 Q 的选择。

为什么要这个 Q 尽可能大呢？主要是为了降低哈希冲突的概率。

因为代码中你把这个 Q 作为除数，余数（哈希值）一定落在 [0, Q-1] 之间，所以 Q 越大，哈希值的空间就越大，就越不容易出现哈希冲突，整个算法的效率就会高一些。

为什么这个 Q 要是素数呢？依然是为了降低哈希冲突的概率。

举个极端一点的例子，你令 Q = 100，那么无论一个数 X 再大，X % Q 的结果必然是 X 的最后两位。换句话说 X 前面的那些位你根本没利用，可想而知你这个哈希算法存在某些规律性，不够随机，进而更容易导致哈希冲突，降低算法的效率。
*/
